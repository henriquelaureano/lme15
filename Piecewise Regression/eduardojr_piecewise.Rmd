---
output: 
  html_document:
    css: style.css
    self_contained: no
    toc: false
---

<center>
<hr style="height:2px;border:none;color:#333;background-color:#333;" />
</center>

<center>
<h1> Modelos de Regressão Segmentada </h1>
CE092 - Extensões de Modelos de Regressão  
Universidade Federal do Paraná  
Data
</center>

<center>
<hr style="height:2px;border:none;color:#333;background-color:#333;" />
</center>  

<div id="TOC" style='width:400px; background-color: #F7F7F7; border-radius:0px; border: 1px #EEEEEE solid;' >
<ul>
<li><a href="#introducao">Introdução</a></li>
<li><a href="#estudos-de-caso">Estudos de caso</a></li>
<li><a href="#discussao">Discussão</a></li>
</ul>
</div>

```{r setup, include=FALSE}
##-----------------------------------------------------------------------------
## Knitr settings. Do not run.
library(knitr)
opts_chunk$set(
    tidy=FALSE,
    cache = TRUE,
    cache.path = "cache/",
    fig.path = "figures/",
    echo=TRUE,
    message=FALSE,
    error=FALSE,
    warning=FALSE,
    fig.align='center')
options(width=70)

```

## Introdução

> $$ \begin{align}
\hat{y_i} &= \beta_0 + \beta_1 x_i, \quad y_i < b \\
\hat{y_i} &= \beta_0 + \beta_1 b + \beta_2(x_i - c), \quad y_i \geq b
\end{align} $$

<p></p>
```{r, echo=FALSE, fig.height=5, fig.width=8}
##----------------------------------------------------------------------
## Gráfico para exemplificação de um modelo de regressão segmentada

##Definição de cores
col1 <- "aquamarine4"; col2 <- "steelblue4"
plot(NULL, xlim = c(0, 5), ylim = c(3, 15), axes = FALSE,
     xlab = "", ylab = ""); axis(1, at = 0)
## Segmentos da regressão
curve(5 + 1*x, from = -1, to = 3, add = TRUE, lwd = 2,
      col = col1)
## curve(5 + 1*x, from = 3, to = 7, add = TRUE, lty = 2)
curve(5 + 3 + (10/3)*(x - 3), from = 3, to = 7, lwd = 2, add = TRUE,
      col = col2)
## Layout gráfico
axis(2, at = axTicks(2), labels = FALSE, col = "gray50")
axis(4, at = axTicks(2), labels = FALSE, col = "gray50")
axis(1, at = axTicks(1), labels = FALSE, col = "gray50")
axis(3, at = axTicks(1), labels = FALSE, col = "gray50")
grid();box()
title(main = "Regressão Segmentada")
mtext("Discentes CE092, 2015", side = 1, adj = 1, line = 1)
## Segmentos auxiliares para os angulos
segments(-1, 5, 0, 5, lty = 3, col = "black")
segments(0, 0, 0, 5, lty = 3, col = "black")
segments(-1, 8, 3, 8, lty = 3, col = "black")
segments(3, 0, 3, 8, lty = 3, col = "black")
segments(1, 6, 1.5, 6, lty = 2)
segments(3, 8, 3.5, 8.5, lty = 2)
## Parametros no grafico
axis(1, at = 3, col = "black", lwd = 2,
     labels = expression(italic(b)))
axis(2, at = 5, las = 2, col = "black", lwd = 2,
     labels = expression(beta[0]))
axis(2, at = 8, las = 2, col = "black", lwd = 2,
     labels = expression(italic(b[y])))
text(1.6, 6.3, labels = expression(beta[1]))
text(3.5, 8.9, labels = expression(beta[2]))
## Função de regressão
form1 <- expression(italic(hat(Y)~"="~beta[0]~"+"~beta[1]~X~","~~~"se"~X<b))
form2 <- expression(italic(hat(Y)~"="~beta[0]~"+"~beta[1]~b~"+"~beta[2](x~"-"~b)~","~~~"se"~X>=b))
legend(0, 15, col=c(col1, col2), lty=1, lwd=3, bty="n", cex = 1,
       legend = c(form1, form2), title = "Definição do Modelo")
```

## Estudos de caso

Para compreensão da estrutura do modelo de regressão linear segmentado é realizada a análise do conjunto de dados [df02.txt](leg.ufpr.br/lib/exe/fetch.php/disciplinas:ce092-2015-02:df02.txt) no qual será considerado um único ponto de quebra conhecido.

Utilizamos as variáveis **Y1** e **x** do conjunto de dados, como variáveis dependente e regressora respectivamente.

```{r}
df02 <- read.table("df02.txt", head=TRUE)

## Visualização preliminar
plot(Y1 ~ x, data = df02, pch = 19); grid()
```

Para ajuste de segmentos podemos utilizar a função *linear models (lm)*. Uma forma ingênua de estimar os coeficientes deste modelo é ajustar dois modelos somente estratificando os dados. Esta abordagem é exemplificada abaixo:

```{r}
## Modelos de regressão linear independentes considerando o ponto de
## quebra b 
b <- 1.5
m1 <- lm(Y1 ~ x, data = subset(df02, x < b))
m2 <- lm(Y1 ~ x, data = subset(df02, x > b | x == b))

plot(Y1 ~ x, data = df02, pch = 19); grid()
abline(v = b, lty = 2)
abline(coef(m1), col = 3)
abline(coef(m2), col = 4)
```


Esta abordagem não faz nenhuma restrição para que a função seja contínua, com isso temos uma descontinuidade no ponto de quebra. Esta restrição é incluída na função **lm** com a adição de uma coluna na matrix de delineamento.

```{r}
m0 <- lm(Y1 ~ x + I(pmax(x - b, 0)), data = df02)

newdata <- seq(0, 2, len = 1000)
pred <- predict(m0, newdata = data.frame(x= newdata))
pred <- cbind(newdata, pred)

plot(Y1 ~ x, data = df02, pch = 19); grid()
lines(pred ~ newdata, data = pred, col = 3)
```

```{r}
model.matrix(m0)
```

## Discussão

```{r, echo = FALSE, cache=FALSE, eval=FALSE}
da <- read.table("df02.txt", head=TRUE)

shinyApp(

ui = fixedPage(fixed = TRUE,

    sidebarLayout(fluid = FALSE, 
        sidebarPanel(width = 4,
    tags$head(
    tags$style(type="text/css", "select { max-width: 140px; }"),
    tags$style(type="text/css", ".span4 { max-width: 190px; }"),
    tags$style(type="text/css", ".well { max-width: 180px; }")
  ),
  p("Soma de quadrados dos resíduos"),
              verbatimTextOutput("info"),

              sliderInput(inputId="b",
                            label="Ponto de quebra",
                            min=0,
                            max=2,
                            step=0.1,
                            value=1)
               ),

        mainPanel(width = 8,
               plotOutput("plot1",
                          height = "300px", width = "480px")
               )
        )
    ),

##======================================================================
server = function(input, output) {
    
    output$plot1 <- renderPlot({
        ## Modelos segmentado continuo
        b <- input$b
        m0 <- lm(Y1 ~ x + I(pmax(x - b, 0)), data = df02)
        b0 <- round(coef(m0)[1], 1)
        b1 <- round(coef(m0)[2], 1)
        b2 <- round(coef(m0)[3], 1)
        b0a <- round(b0 + b1 * b, 1)

        form1 <- substitute(
                    italic(hat(Y)~"="~b0~"+"~b1~X~","~~~"se"~X<b),
                    list(b0 = b0, b1 = b1, b = b))
        form2 <- substitute(
                    italic(hat(Y)~"="~b0~"+"~b2(x~"-"~b)~","~~~"se"~X>=b),
                    list(b0 = b0a, b1 = b1, b2 = b2, b = b))

        newdata <- seq(0, 2, len = 1000)
        pred <- predict(m0, newdata = data.frame(x= newdata))
        pred <- cbind(newdata, pred)

        par(mar = c(4, 4, 0, 2) + 0.5)
        plot(Y1 ~ x, data = df02, pch = 19); grid()
        segments(da$x, da$Y1, da$x, fitted(m0), lty = 2, col = "gray50")
        lines(pred ~ newdata, data = pred, lwd = 2)
        points(Y1 ~ x, data = df02, pch = 19)
        mtext(form1, adj = 0.1, line = -3.5, padj = 0)
        mtext(form2, adj = 0.118, line = -5, padj = 0)
    })
    
    output$info <- renderText({
        b <- input$b
        m0 <- lm(Y1 ~ x + I(pmax(x - b, 0)), data = df02)
        sum(residuals(m0)^2)
    })
    
},
    options = list(height = 300)
)
```

<iframe src="http://shiny.leg.ufpr.br/eduardo/reg_seg/" width=100% height = 300 frameborder="0" scrolling="no" marginheight="0" marginwidth="0"> </iframe>


Método de mínimos quadrados para encontrar o ponto de quebra ótimo é válido ? 

```{r echo=FALSE, message=FALSE, warning=FALSE}
require(animation)

newdata <- seq(0, 2, len = 1000)
seq.b <- seq(0, 2, 0.05)
desvios <- rep(NA, length(seq.b))

## setwd(paste(getwd(), "/html", sep=""))
saveHTML(
    for(i in 1:length(seq.b)){
        b <- seq.b[i]
        m0 <- lm(Y1 ~ x + I(pmax(x - b, 0)), data = df02)
        beta <- coefficients(m0)

        desvios[i] <- sum(residuals(m0)^2)
        
        cols <- c(rep(3, sum(df02$x < seq.b[i])),
                  rep(4, sum(df02$x > seq.b[i] | df02$x == seq.b[i])))
        
        par(mfrow = c(1, 2))
        plot(Y1 ~ x, data = df02, pch = 19, col = cols); grid()

        if(b == 0){
            abline(a = coef(m0)[1], b = coef(m0)[2], col = 4, lwd = 2)
        }
        if(b == 2){
            abline(a = coef(m0)[1], b = coef(m0)[2], col = 3, lwd = 2)
        }
        if(b != 0 & b != 2){
            curve(beta[1] + beta[2] * x, from = 0, to = b,
                  col = 3, add = TRUE)
        
            curve(beta[1] + beta[2] * b + (beta[3] + beta[2]) * (x - b),
                  from = b, to = 2,
                  col = 4, lwd = 2, add = TRUE)
        }
        
        plot(seq.b, desvios, type = "o", pch = 19, xlab = "Pontos de Quebra"); grid()
        ani.pause()
    },
    img.name = "anima", imgdir = "anima",
    ani.width = 600,
    ani.height = 400,
    interval = 0.1,
    htmlfile = "anima.html",
    verbose = FALSE)
```

<iframe src="anima.html" width=100% height = 600 frameborder="0" scrolling="no" marginheight="0" marginwidth="0"> </iframe>









